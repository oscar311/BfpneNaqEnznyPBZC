
AVRASM ver. 2.2.6  C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm Fri Jun 02 02:01:13 2017

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(80): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(81): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/macros.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(82): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/lcd.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(83): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/timer0.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(84): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/keypad.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(317): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/AdminScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(318): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/CoinReturn.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(319): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/CoinScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(320): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/DeliverScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(321): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/EmptyScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(322): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/SelectScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(323): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/StartScreen.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(80): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(81): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/macros.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(82): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/lcd.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(83): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/timer0.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(84): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/keypad.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(317): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/AdminScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(318): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/CoinReturn.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(319): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/CoinScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(320): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/DeliverScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(321): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/EmptyScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(322): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/SelectScreen.asm'
C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\main.asm(323): Including file 'C:\Users\Ramal\Uni Work\COMP2121\Project\AssemblerApplication1\AssemblerApplication1\modules/StartScreen.asm'
                                 
                                 .equ inStart =  1
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #define _M2560DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega2560
                                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x98
                                 .equ	SIGNATURE_002	= 0x01
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                                 .equ	PINL	= 0x109	; MEMORY MAPPED
                                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                                 .equ	PINK	= 0x106	; MEMORY MAPPED
                                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                                 .equ	PINH	= 0x100	; MEMORY MAPPED
                                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR5	= 0x1a
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTG	= 0x14
                                 .equ	DDRG	= 0x13
                                 .equ	PING	= 0x12
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	PORTA	= 0x02
                                 .equ	DDRA	= 0x01
                                 .equ	PINA	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 .equ	PORTG5	= 5	; 
                                 .equ	PG5	= 5	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 .equ	DDG5	= 5	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 .equ	PING5	= 5	; 
                                 
                                 
                                 ; ***** PORTH ************************
                                 ; PORTH - PORT H Data Register
                                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                                 .equ	PH0	= 0	; For compatibility
                                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                                 .equ	PH1	= 1	; For compatibility
                                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                                 .equ	PH2	= 2	; For compatibility
                                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                                 .equ	PH3	= 3	; For compatibility
                                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                                 .equ	PH4	= 4	; For compatibility
                                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                                 .equ	PH5	= 5	; For compatibility
                                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                                 .equ	PH6	= 6	; For compatibility
                                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                                 .equ	PH7	= 7	; For compatibility
                                 
                                 ; DDRH - PORT H Data Direction Register
                                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                                 
                                 ; PINH - PORT H Input Pins
                                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                                 
                                 
                                 ; ***** PORTJ ************************
                                 ; PORTJ - PORT J Data Register
                                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                                 .equ	PJ0	= 0	; For compatibility
                                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                                 .equ	PJ1	= 1	; For compatibility
                                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                                 .equ	PJ2	= 2	; For compatibility
                                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                                 .equ	PJ3	= 3	; For compatibility
                                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                                 .equ	PJ4	= 4	; For compatibility
                                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                                 .equ	PJ5	= 5	; For compatibility
                                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                                 .equ	PJ6	= 6	; For compatibility
                                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                                 .equ	PJ7	= 7	; For compatibility
                                 
                                 ; DDRJ - PORT J Data Direction Register
                                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                                 
                                 ; PINJ - PORT J Input Pins
                                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                                 
                                 
                                 ; ***** PORTK ************************
                                 ; PORTK - PORT K Data Register
                                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                                 .equ	PK0	= 0	; For compatibility
                                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                                 .equ	PK1	= 1	; For compatibility
                                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                                 .equ	PK2	= 2	; For compatibility
                                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                                 .equ	PK3	= 3	; For compatibility
                                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                                 .equ	PK4	= 4	; For compatibility
                                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                                 .equ	PK5	= 5	; For compatibility
                                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                                 .equ	PK6	= 6	; For compatibility
                                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                                 .equ	PK7	= 7	; For compatibility
                                 
                                 ; DDRK - PORT K Data Direction Register
                                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                                 
                                 ; PINK - PORT K Input Pins
                                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                                 
                                 
                                 ; ***** PORTL ************************
                                 ; PORTL - PORT L Data Register
                                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                                 .equ	PL0	= 0	; For compatibility
                                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                                 .equ	PL1	= 1	; For compatibility
                                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                                 .equ	PL2	= 2	; For compatibility
                                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                                 .equ	PL3	= 3	; For compatibility
                                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                                 .equ	PL4	= 4	; For compatibility
                                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                                 .equ	PL5	= 5	; For compatibility
                                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                                 .equ	PL6	= 6	; For compatibility
                                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                                 .equ	PL7	= 7	; For compatibility
                                 
                                 ; DDRL - PORT L Data Direction Register
                                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                                 
                                 ; PINL - PORT L Input Pins
                                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_5 **************
                                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                                 
                                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                                 .equ	ICF5	= 5	; Input Capture Flag 5
                                 
                                 ; TCCR5A - Timer/Counter5 Control Register A
                                 .equ	WGM50	= 0	; Waveform Generation Mode
                                 .equ	WGM51	= 1	; Waveform Generation Mode
                                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR5B - Timer/Counter5 Control Register B
                                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                                 .equ	WGM52	= 3	; Waveform Generation Mode
                                 .equ	WGM53	= 4	; Waveform Generation Mode
                                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                                 
                                 ; TCCR5C - Timer/Counter 5 Control Register C
                                 .equ	FOC5C	= 5	; Force Output Compare 5C
                                 .equ	FOC5B	= 6	; Force Output Compare 5B
                                 .equ	FOC5A	= 7	; Force Output Compare 5A
                                 
                                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                                 
                                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                                 .equ	ICF4	= 5	; Input Capture Flag 4
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	WGM40	= 0	; Waveform Generation Mode
                                 .equ	WGM41	= 1	; Waveform Generation Mode
                                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                                 .equ	WGM42	= 3	; Waveform Generation Mode
                                 .equ	WGM43	= 4	; Waveform Generation Mode
                                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	FOC4C	= 5	; Force Output Compare 4C
                                 .equ	FOC4B	= 6	; Force Output Compare 4B
                                 .equ	FOC4A	= 7	; Force Output Compare 4A
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW00	= 0	; Wait state select bit lower page
                                 .equ	SRW01	= 1	; Wait state select bit lower page
                                 .equ	SRW10	= 2	; Wait state select bit upper page
                                 .equ	SRW11	= 3	; Wait state select bit upper page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRUSART2	= 1	; Power Reduction USART2
                                 .equ	PRUSART3	= 2	; Power Reduction USART3
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                                 ;.equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 .equ	ADC6D	= 6	; 
                                 .equ	ADC7D	= 7	; 
                                 
                                 ; DIDR2 - Digital Input Disable Register
                                 .equ	ADC8D	= 0	; 
                                 .equ	ADC9D	= 1	; 
                                 .equ	ADC10D	= 2	; 
                                 .equ	ADC11D	= 3	; 
                                 .equ	ADC12D	= 4	; 
                                 .equ	ADC13D	= 5	; 
                                 .equ	ADC14D	= 6	; 
                                 .equ	ADC15D	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** USART2 ***********************
                                 ; UDR2 - USART I/O Data Register
                                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR2A - USART Control and Status Register A
                                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                                 .equ	U2X2	= 1	; Double the USART transmission speed
                                 .equ	UPE2	= 2	; Parity Error
                                 .equ	DOR2	= 3	; Data overRun
                                 .equ	FE2	= 4	; Framing Error
                                 .equ	UDRE2	= 5	; USART Data Register Empty
                                 .equ	TXC2	= 6	; USART Transmitt Complete
                                 .equ	RXC2	= 7	; USART Receive Complete
                                 
                                 ; UCSR2B - USART Control and Status Register B
                                 .equ	TXB82	= 0	; Transmit Data Bit 8
                                 .equ	RXB82	= 1	; Receive Data Bit 8
                                 .equ	UCSZ22	= 2	; Character Size
                                 .equ	TXEN2	= 3	; Transmitter Enable
                                 .equ	RXEN2	= 4	; Receiver Enable
                                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR2C - USART Control and Status Register C
                                 .equ	UCPOL2	= 0	; Clock Polarity
                                 .equ	UCSZ20	= 1	; Character Size
                                 .equ	UCSZ21	= 2	; Character Size
                                 .equ	USBS2	= 3	; Stop Bit Select
                                 .equ	UPM20	= 4	; Parity Mode Bit 0
                                 .equ	UPM21	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL20	= 6	; USART Mode Select
                                 .equ	UMSEL21	= 7	; USART Mode Select
                                 
                                 ; UBRR2H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR2L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART3 ***********************
                                 ; UDR3 - USART I/O Data Register
                                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR3A - USART Control and Status Register A
                                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                                 .equ	U2X3	= 1	; Double the USART transmission speed
                                 .equ	UPE3	= 2	; Parity Error
                                 .equ	DOR3	= 3	; Data overRun
                                 .equ	FE3	= 4	; Framing Error
                                 .equ	UDRE3	= 5	; USART Data Register Empty
                                 .equ	TXC3	= 6	; USART Transmitt Complete
                                 .equ	RXC3	= 7	; USART Receive Complete
                                 
                                 ; UCSR3B - USART Control and Status Register B
                                 .equ	TXB83	= 0	; Transmit Data Bit 8
                                 .equ	RXB83	= 1	; Receive Data Bit 8
                                 .equ	UCSZ32	= 2	; Character Size
                                 .equ	TXEN3	= 3	; Transmitter Enable
                                 .equ	RXEN3	= 4	; Receiver Enable
                                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR3C - USART Control and Status Register C
                                 .equ	UCPOL3	= 0	; Clock Polarity
                                 .equ	UCSZ30	= 1	; Character Size
                                 .equ	UCSZ31	= 2	; Character Size
                                 .equ	USBS3	= 3	; Stop Bit Select
                                 .equ	UPM30	= 4	; Parity Mode Bit 0
                                 .equ	UPM31	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL30	= 6	; USART Mode Select
                                 .equ	UMSEL31	= 7	; USART Mode Select
                                 
                                 ; UBRR3H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR3L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                                 .equ	IOEND	= 0x01ff
                                 .equ	SRAM_START	= 0x0200
                                 .equ	SRAM_SIZE	= 8192
                                 .equ	RAMEND	= 0x21ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 262144
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1f000
                                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1efff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0x1fe00
                                 .equ	SECONDBOOTSTART	= 0x1fc00
                                 .equ	THIRDBOOTSTART	= 0x1f800
                                 .equ	FOURTHBOOTSTART	= 0x1f000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                                 
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 .equ inSelect = 2
                                 .equ inCoin = 3
                                 .equ inEmpty = 4
                                 .equ ADCCoin = 6
                                 .equ inReturn = 5
                                 .equ inDeliver = 7
                                 .equ inAdmin = 8
                                 
                                 .equ aKey = 20
                                 .equ bKey = 21
                                 .equ cKey = 22
                                 .equ dKey = 23
                                 .equ asterix = 24
                                 .equ hash = 25
                                 .equ zeroButton = 26
                                 
                                 .equ turnLEDOff = 0b11010000
                                 .equ turnLEDOn =  0b00101111
                                 .equ turnMotOn = 0b11010000
                                 
                                 .def currFlag = r4
                                 .def oldFlag = r5
                                 .def keyPress = r6
                                 .def keyID = r7
                                 .def potPos = r8
                                 .def coinsToReturn = r9 
                                 .def coinsEntered = r10	
                                 .def coinsRequired = r11
                                 .def keyDebounce = r12
                                 .def currItem = r13
                                 .def asterixPressed = r14
                                 
                                 .def row = r16
                                 .def col = r17
                                 .def rmask = r18                ; mask for row
                                 .def cmask = r19                ; mask for column
                                 .def temp = r20
                                 .def temp1 = r21
                                 .def ADCLow = r22
                                 .def ADCHigh = r23
                                 
                                 								;we have up to and including r25
                                 
                                 .dseg 
                                 LEDCounter:
000200                               .byte 2             ; Temporary counter. Counts milliseconds
                                 DisplayCounter:
000202                               .byte 2             ; counts number of milliseconds for displays.
                                 ReturnCounter:
000204                           	.byte 2
                                 AsterixCounter:
000206                           	.byte 2
                                 SoundCounter:
000208                           	.byte 2
                                 ADCCounter:
00020a                           	.byte 2
                                 Inventory:
00020c                           	.byte 9
                                 Cost:
000215                           	.byte 9	
                                 
                                 
                                 .cseg
                                 .org 0x0000
000000 940c 01c8                    jmp RESET
                                 .org INT0addr
000002 940c 089e                 	jmp EXT_INT0		
                                 .org INT1addr
000004 940c 08a8                    jmp EXT_INT1
                                 .org OVF0addr
00002e 940c 009b                    jmp Timer0OVF        ; Jump to the interrupt handler for timer 0
                                 .org ADCCaddr
00003a 940c 0893                 	jmp EXT_POT
                                 
                                 
00003c 940c 003e                 jmp DEFAULT          ; default service for all other interrupts.
00003e 9518                      DEFAULT:  reti          ; no service
                                 
                                 .include "m2560def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 .include "modules/macros.asm"
                                 
                                 ; the parameter @0 is the memory address for that word
                                 .macro clear
                                     ldi YL, low(@0)     ; load the memory address to Y
                                     ldi YH, high(@0)
                                     clr temp 
                                     st Y+, temp         ; clear the two bytes at @0 in SRAM
                                     st Y, temp
                                 .endmacro
                                 
                                 
                                 .macro do_lcd_command
                                     push r16
                                     ldi r16, @0
                                     rcall lcd_command
                                     rcall lcd_wait
                                     pop r16
                                 .endmacro
                                 
                                 
                                 /*
                                     @0 - register containing desired index (not temp!)
                                     @1 - address of array to read from
                                     @2 - register to write value to
                                 */
                                 .macro get_element
                                     push XL
                                     push XH
                                     push @0
                                     push temp
                                     in temp, SREG
                                     push temp   
                                     
                                     ldi XL, low(@1)
                                     ldi XH, high(@1)
                                 
                                     loop:
                                     cpi @0, 1
                                     breq getVal
                                     subi @0, 1
                                     adiw XH:XL, 1
                                     jmp loop
                                     
                                     getVal:
                                     clr @2
                                     ld @2, X
                                     
                                     pop temp
                                     out SREG, temp
                                     pop temp
                                     pop @0
                                     pop XH
                                     pop XL
                                 .endmacro
                                 
                                 /*
                                     @0 - register containing desired index (not temp!)
                                     @1 - address of array to write to
                                     @2 - register to write value from
                                 */
                                 .macro set_element
                                     push XL
                                     push XH
                                     push @0
                                     push temp
                                     in temp, SREG
                                     push temp
                                     
                                     ldi XL, low(@1)
                                     ldi XH, high(@1)
                                 
                                     loop:
                                     cpi @0, 1
                                     breq setVal
                                     subi @0, 1
                                     adiw XH:XL, 1
                                     jmp loop
                                     
                                     setVal:
                                     st X, @2
                                 
                                     pop temp
                                     out SREG, temp
                                     pop temp
                                     pop @0
                                     pop XH
                                     pop XL
                                 .endmacro
                                 
                                 .macro set_reg
                                     push temp
                                     ldi temp, @1
                                     mov @0, temp
                                     pop temp
                                 .endmacro
                                 
                                 .macro clr_reg
                                     push temp
                                     clr temp
                                     mov @0, temp
                                     pop temp
                                 .endmacro
                                 
                                 .macro do_lcd_data
                                     push r16
                                     mov r16, @0
                                     subi r16, -'0'
                                     rcall lcd_data
                                     rcall lcd_wait
                                     pop r16
                                 .endmacro
                                 
                                 .macro do_lcd_data_i
                                 	push r16
                                 	ldi r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 	pop r16
                                 .endmacro
                                 
                                 .macro lcd_set
                                     sbi PORTA, @0           //set a bit (specified by @0) in portA
                                 .endmacro
                                 
                                 .macro lcd_clr
                                     cbi PORTA, @0           //clear a bit (specified by @0) in portA
                                 .endmacro
                                 
                                 .macro check_coins_zero
                                     push r16
                                     ldi r16, 0               
                                     cp coinsToReturn, r16
                                     pop r16
                                 .endmacro
                                 
                                 
                                 
                                     
                                 
                                 .include "modules/lcd.asm"
                                 
                                 
                                 .equ LCD_RS = 7
                                 .equ LCD_E = 6
                                 .equ LCD_RW = 5
                                 .equ LCD_BE = 4
                                 
                                 lcd_command:
00003f bb01                          out PORTF, r16          //write out a control command to LCD
000040 d01f                          rcall sleep_1ms
000041 9a16                          lcd_set LCD_E
000042 d01d                          rcall sleep_1ms
000043 9816                          lcd_clr LCD_E
000044 d01b                          rcall sleep_1ms
000045 9508                          ret
                                 
                                 lcd_data:
000046 bb01                          out PORTF, r16          // write out data to LCD
000047 9a17                          lcd_set LCD_RS
000048 d017                          rcall sleep_1ms
000049 9a16                          lcd_set LCD_E
00004a d015                          rcall sleep_1ms
00004b 9816                          lcd_clr LCD_E
00004c d013                          rcall sleep_1ms
00004d 9817                          lcd_clr LCD_RS
00004e 9508                          ret
                                 
                                 lcd_wait:
00004f 930f                          push r16
000050 2700                          clr r16
000051 bb00                          out DDRF, r16               // set port F as input
000052 bb01                          out PORTF, r16
000053 9a15                          lcd_set LCD_RW
                                         
                                 lcd_wait_loop:
000054 d00b                          rcall sleep_1ms
000055 9a16                          lcd_set LCD_E
000056 d009                          rcall sleep_1ms
000057 b10f                          in r16, PINF
000058 9816                          lcd_clr LCD_E
000059 fd07                          sbrc r16, 7                 // check if busy flag has been cleared
00005a cff9                          rjmp lcd_wait_loop          //if its still busy then it waits longer
00005b 9815                          lcd_clr LCD_RW
00005c ef0f                          ser r16
00005d bb00                          out DDRF, r16               // Port F to output
00005e 910f                          pop r16
00005f 9508                          ret
                                 
                                 .equ F_CPU = 16000000
                                 .equ DELAY_1MS = F_CPU / 4 / 1000 - 4
                                 ; 4 cycles per iteration - setup/call-return overhead
                                 
                                 sleep_1ms:
000060 938f                          push r24
000061 939f                          push r25
000062 e09f                          ldi r25, high(DELAY_1MS)
000063 e98c                          ldi r24, low(DELAY_1MS)
                                 delayloop_1ms:
000064 9701                          sbiw r25:r24, 1
000065 f7f1                          brne delayloop_1ms
000066 919f                          pop r25
000067 918f                          pop r24
000068 9508                          ret
                                 
                                 sleep_5ms:
000069 dff6                          rcall sleep_1ms
00006a dff5                          rcall sleep_1ms
00006b dff4                          rcall sleep_1ms
00006c dff3                          rcall sleep_1ms
00006d dff2                          rcall sleep_1ms
00006e 9508                          ret
                                 
                                 /*
                                 */
                                 print_digits:
00006f 934f                          push temp
000070 b74f                          in temp, SREG
000071 934f                          push temp
000072 935f                          push temp1
000073 930f                          push r16
000074 2755                          clr temp1
                                 
                                     hundreds:                   ; counts the number of hundreds
000075 e644                          ldi temp, 100              
000076 3604                          cpi  r16, 100
000077 f020                          brlo hundred_print
000078 1b04                          sub  r16, temp
000079 9553                          inc temp1
00007a 940c 0075                     jmp hundreds
                                 
                                     hundred_print:
00007c d016                          rcall print                 ; prints the hundredth digit
                                 
                                     tens:                       ; likewise for tens and ones....
00007d e04a                          ldi temp, 10
00007e 300a                          cpi  r16, 10
00007f f020                          brlo tens_print
000080 1b04                          sub  r16, temp
000081 9553                          inc temp1
000082 940c 007d                     jmp tens
                                 
                                     tens_print:
000084 d00e                          rcall print
                                 
                                     ones:
000085 e041                          ldi temp, 1
000086 1704                          cp  r16, temp
000087 f020                          brlo ones_print
000088 1b04                          sub  r16, temp
000089 9553                          inc temp1
00008a 940c 0085                     jmp ones
                                 
                                     ones_print:
00008c d006                          rcall print
                                 
00008d 910f                          pop r16
00008e 915f                          pop temp1
00008f 914f                          pop temp
000090 bf4f                          out SREG, temp
000091 914f                          pop temp
000092 9508                          ret
                                 
                                 print:
000093 930f
000094 2f05
000095 5d00
000096 dfaf
000097 dfb7
000098 910f                          do_lcd_data temp1          ;prints number in temp1
000099 2755                          clr temp1
                                 .include "modules/timer0.asm"
00009a 9508                      
                                 ===================================================================
                                 COMP2121                                                        
                                 Project - Vending Machine
                                 timer0
                                 
                                 
                                 Interrupt subroutine for the sole timer for the whole system. 
                                 Timing used for:
                                     - Screen transistions
                                     - Turning off LEDs
                                     - Turning off Motor
                                     - Returning coins
                                 ===================================================================
                                 */
                                 
                                 .equ INTS_PER_MS = 8                                    ; time per interrupt = (1/(16E6)) * (2^8 - 1) * 8 <- pre scaler = 127.5 us
                                                                                         ; number of interrupts per second = (1E-3) / (127.5)E-6 = 7.843 ~ 8
                                 
                                 
                                 
                                 Timer0OVF: ; interrupt subroutine to Timer0
00009b 934f                          push temp
00009c b74f                          in temp, SREG
00009d 934f                          push temp                                       ; Prologue starts.
00009e 935f                          push temp1
00009f 93df                          push YH                                         ; Save all conflict registers in the prologue.
0000a0 93cf                          push YL
0000a1 938f                          push r24
0000a2 939f                          push r25
0000a3 93af                          push r26
0000a4 93bf                          push r27
                                 
                                 
                                 
                                                     /* Just increases a counter (every ms) when a "*" is pressed */
                                                     /* ========================================================= */
0000a5 2411                          clr r1
0000a6 14e1                          cp asterixPressed, r1                           ; poll 'asterix pressed' flag 
0000a7 f049                          breq noAsterix                                  ; asterix is not currently pressed so dont count
                                 
0000a8 91a0 0206                     lds r26, AsterixCounter                         ; else start counting 
0000aa 91b0 0207                     lds r27, AsterixCounter+1
0000ac 9611                          adiw r27:r26, 1
                                 
0000ad 93a0 0206                     sts AsterixCounter, r26
0000af 93b0 0207                     sts AsterixCounter +1, r27
                                     
                                     noAsterix:
                                 
                                    
                                                             /* Enables the ADC Reader every millisecond */ 
                                                             /* ======================================== */
                                 
0000b1 2d54                          mov temp1, currFlag
0000b2 3056                          cpi temp1, ADCCoin
0000b3 f4c1                          brne skipADC                                    ; dont enable ADC if not in coin screen
                                 
0000b4 91a0 020a                     lds r26, ADCCounter
0000b6 91b0 020b                     lds r27, ADCCounter+1
0000b8 9611                          adiw r27:r26, 1
                                 
0000b9 30a8                          cpi r26, low(1*INTS_PER_MS)                     ; 1ms check
0000ba e040                          ldi temp, high(1*INTS_PER_MS) 
0000bb 07b4                          cpc r27, temp
0000bc f459                          brne finishADC
                                 
                                        
0000bd 9140 007a                     lds temp, ADCSRA
0000bf 6440                          ori temp, (1 << ADSC)               
0000c0 9340 007a                     sts ADCSRA, temp                                ; enabling the ADC reader which will interrupt when conversion done
                                 
0000c2 e0ca
0000c3 e0d2
0000c4 2744
0000c5 9349
0000c6 8348                          clear ADCCounter                                ; clear counter for next ADC request
0000c7 c004                          rjmp skipADC
                                 
                                     finishADC:
0000c8 93a0 020a                     sts ADCCounter, r26
0000ca 93b0 020b                     sts ADCCounter +1, r27
                                     
                                     skipADC:
                                 
                                                         /* Times 3 seconds for screen transition and motor off */ 
                                                         /* =================================================== */
                                 
0000cc 91a0 0202                     lds r26, DisplayCounter
0000ce 91b0 0203                     lds r27, DisplayCounter+1
0000d0 9611                          adiw r27:r26, 1
                                     
                                 
0000d1 3ca0                          cpi r26, low(3000*INTS_PER_MS)                  ; 3 second check
0000d2 e54d                          ldi temp, high(3000*INTS_PER_MS) 
0000d3 07b4                          cpc r27, temp
0000d4 f449                          brne skipDisplay                                ; not 3 seconds yet
                                     
0000d5 d18c                          rcall start_to_select                           ; if the start screen needs to be changed
0000d6 d19a                          rcall empty_to_select                           ; if the empty screen needs to be changed
0000d7 d1c6                          rcall deliver_to_select                         ; if the deliver screen needs to be changed (and trigger motor off))
                                 
0000d8 e0c2
0000d9 e0d2
0000da 2744
0000db 9349
0000dc 8348                          clear DisplayCounter 
0000dd c04c                          rjmp EndIF
                                 
                                     skipDisplay:
                                 
0000de 93a0 0202                     sts DisplayCounter, r26
0000e0 93b0 0203                     sts DisplayCounter +1, r27
                                 
                                 
                                                                 /* Times 1.5 seconds to turn LEDs off */ 
                                                                 /* ================================== */
                                 
0000e2 91a0 0200                     lds r26, LEDCounter
0000e4 91b0 0201                     lds r27, LEDCounter+1
0000e6 9611                          adiw r27:r26, 1
                                     
0000e7 e044                          ldi temp, inEmpty                               
0000e8 1644                          cp currFlag, temp                               ; if currently in Empty screen
0000e9 f019                          breq flash
                                 
0000ea e047                          ldi temp, inDeliver
0000eb 1644                          cp currFlag, temp                               ; else if in deliver screen
0000ec f491                          brne skipLED                                    ; if not in any of these then skip all 
                                 
                                     flash:
0000ed 3ea0                          cpi r26, low(1500*INTS_PER_MS)                  ; 1.5 second check
0000ee e24e                          ldi temp, high(1500*INTS_PER_MS) 
0000ef 07b4                          cpc r27, temp
0000f0 f471                          brne skipLED
                                     
0000f1 e0c0
0000f2 e0d2
0000f3 2744
0000f4 9349
0000f5 8348                          clear LEDCounter                                ; clear counter for next check
                                 
0000f6 2744                          clr temp                           
0000f7 b948                          out PORTC, temp                                     
0000f8 b94e                          out PORTE, temp                                 ; write LOW to both LED ports to turn off (which also turns off motor)
                                     
0000f9 e047                          ldi temp, inDeliver                             ; check if in deliver screen 
0000fa 1644                          cp currFlag, temp
0000fb f571                          brne EndIF                                      ; if not, then done
                                 
0000fc ed40                          ldi temp, turnLEDOff                            ; else if, write individual bits to keep only motor on for longer
0000fd b94e                          out PORTE, temp
                                 
0000fe c02b                          rjmp EndIF
                                 
                                     skipLED:
                                 
0000ff 93a0 0200                     sts LEDCounter, r26
000101 93b0 0201                     sts LEDCounter +1, r27
                                 
                                 
                                                             /* Times 0.25 seconds to turn motor on for coin return */ 
                                                             /* =================================================== */
000103 91a0 0204                     lds r26, ReturnCounter
000105 91b0 0205                     lds r27, ReturnCounter+1
000107 9611                          adiw r27:r26, 1
                                 
000108 3da0                          cpi r26, low(250*INTS_PER_MS)                   ; 0.25 second check to turn off motor
000109 e047                          ldi temp, high(250*INTS_PER_MS) 
00010a 07b4                          cpc r27, temp
00010b f441                          brne skipOff                                    ; not enough time yet
                                 
00010c 930f
00010d e000
00010e 1690
00010f 910f                          check_coins_zero                                ; macro that checks whether any coins are still stored in the system
000110 f0c9                          breq EndIF                                      ; if not, then don't need to do anything here
                                 
000111 2755                          clr temp1
000112 b95e                          out PORTE, temp1                                ; otherwise, turn motor off
                                     
000113 949a                          dec coinsToReturn                               ; a coin has been returned so decrement amount in system
                                 
                                 
                                 skipOff:
000114 3aa0                          cpi r26, low(500*INTS_PER_MS)                   ; 0.5 second check to turn on motor
000115 e04f                          ldi temp, high(500*INTS_PER_MS) 
000116 07b4                          cpc r27, temp
000117 f471                          brne skipOn
                                     
000118 930f
000119 e000
00011a 1690
00011b 910f                          check_coins_zero                                ; macro that checks whether any coins are still stored in the system
00011c f069                          breq EndIf                                      ; if not, then don't need to do anything here
                                     
00011d ed50                          ldi temp1, turnMotOn 
00011e b95e                          out PORTE, temp1                                ; otherwise, turn motor off
                                 
00011f e0c4
000120 e0d2
000121 2744
000122 9349
000123 8348                          clear ReturnCounter                             ; clear counter for next coin return request
000124 940c 012a                     jmp EndIF
                                 
                                     skipOn:
000126 93a0 0204                     sts ReturnCounter, r26
000128 93b0 0205                     sts ReturnCounter +1, r27
                                 
                                                                              /* Epilogue */ 
                                                                              /* ======== */
                                     EndIF:
00012a 91bf                          pop r27
00012b 91af                          pop r26
00012c 919f                          pop r25                                 
00012d 918f                          pop r24                                         ; Restore all conflict registers from the stack.
00012e 91cf                          pop YL
00012f 91df                          pop YH
000130 915f                          pop temp1
000131 914f                          pop temp
000132 bf4f                          out SREG, temp
000133 914f                          pop temp
                                 .include "modules/keypad.asm"
000134 9518                      
                                 .equ INITCOLMASK = 0xEF         ; 1110 1111 to check the rightmost column (0 for logic low & 1 for logic high)
                                 .equ INITROWMASK = 0x01         ; 0000 0001 to check the top row (1 to read input) 
                                 .equ ROWMASK = 0x0F             ; for obtaining input from port L
                                 
                                 init_loop:
000135 935f                          push temp1
000136 b75f                          in temp1, SREG
000137 935f                          push temp1
000138 934f                          push temp
                                 
000139 e047                          ldi temp, inDeliver
00013a 1644                          cp currFlag, temp
00013b f409                          brne startLoop
                                 
00013c c075                          rjmp endKeypad
                                 
                                     startLoop:
00013d ee3f                          ldi cmask, INITCOLMASK
00013e 2711                          clr col 
                                     
                                 
                                 colloop:
00013f 3014                          cpi col, 4                  ; if it reached the end of the columns
000140 f409                          brne cont                   
000141 c070                          rjmp endKeypad 
                                     cont:
000142 9330 010b                     sts PORTL, cmask            ; send logic low to certain column to read by row port
                                 
000144 ef4f                          ldi temp, 0xFF   
                                 
                                 delay:  
000145 954a                          dec temp
000146 f7f1                          brne delay                  ; delays process for 255 clocks
                                 
000147 9140 0109                     lds temp, PINL
000149 704f                          andi temp, ROWMASK          ; masking the higher bits (which will be set to output hence garbage)
00014a 304f                          cpi temp, 0xF               ; Check if any of the rows is low (0xF = 0000 1111)
00014b f081                          breq nextCol                ; all rows are high
                                 
00014c 934f
00014d ef4f
00014e 2e64
00014f 914f                          set_reg keyPress, 0xFF
                                 
000150 d111                          rcall start_to_select ; if any button is pressed, change (if applicable) startScreen to selectScreen
                                 
000151 e021                          ldi rmask, INITROWMASK      ;Initialize for row check
000152 2700                          clr row
                                 
                                 rowLoop:
000153 3004                          cpi row, 4                  ; goes to the end of the rows
000154 f039                          breq nextCol                ; the row scan is over
000155 2f54                          mov temp1, temp             ; copying input from pins into temp1
000156 2352                          and temp1, rmask            ; to only check a certain row  (if output is 00 then the Z flag is set)
000157 f041                          breq convert                ; if temp1 is zero (checks zero flag) then jump to convert
000158 9503                          inc row
000159 0f22                          lsl rmask                   ; to unmask the next row
00015a 940c 0153                     jmp rowLoop
                                 
                                 nextCol:
00015c 0f33                          lsl cmask                   ; to unmask the next col
00015d 9513                          inc col                     
00015e 940c 013f                     jmp colloop                 ; in no button pressed jump back to start
                                 
                                 convert:   
000160 3013                          cpi col, 3              
000161 f0d1                          breq letters                ; if one of the letters have been pressed
000162 3003                          cpi row, 3
000163 f439                          brne isNumber               ; row != 3 & col != 3, then its a number
000164 3010                          cpi col, 0
000165 f171                          breq admin            ; row == 3 & col == 0, then the * has been pressed
                                 
000166 24ee                          clr asterixPressed
000167 3011                          cpi col, 1                  
000168 f059                          breq zero                   ; row == 3 & col == 1, then the 0 has been pressed
000169 3012                          cpi col, 2                  
00016a f061                          breq exit                   ; row == 3 & col == 2, then the # has been pressed
                                 
                                     isNumber:                   ; else we convert the binary to an ASCII value
00016b 2f40                          mov temp, row
00016c 0f44                          lsl temp                    ; multiply by 2
00016d 0f40                          add temp, row               ; multiply 3
00016e 0f41                          add temp, col
00016f 5f4f                          subi temp, -1               ; temp now contains the actual number
000170 d039                          rcall debounce_sleep 
000171 2e74                          mov keyID, temp
                                 
000172 d1c9                          rcall updateAdminItem       ; if in Admin mode, change the current item
                                 
000173 c03e                          rjmp endKeypad
                                     
                                 
                                 zero:
000174 e15a                          ldi temp1, zeroButton
000175 2e75                          mov keyID, temp1
000176 c03b                          rjmp endKeypad
                                 
                                 exit:
000177 2466                          clr keyPress
000178 d031                          rcall debounce_sleep 
000179 d0d5                          rcall checkCoins            
00017a d205                          rcall exitAdmin             ; update flags as required
00017b c036                          rjmp endKeypad
                                 
                                 letters:
00017c 3000                          cpi row, 0                  ; if its an A
00017d f039                          breq aButton
00017e 3001                          cpi row, 1                  ; if its a B
00017f f049                          breq bButton
000180 3002                          cpi row, 2                  ; if its a C
000181 f059                          breq cButton
000182 3003                          cpi row, 3                  ; if its a D
000183 f069                          breq dButton
000184 c02d                          rjmp endKeypad
                                     
                                 aButton:
000185 e154                          ldi temp1, aKey
000186 2e75                          mov keyID, temp1
000187 d28b                          rcall adminIncCost
000188 c029                          rjmp endKeypad
                                 
                                 bButton:
000189 e155                          ldi temp1, bKey
00018a 2e75                          mov keyID, temp1
00018b d2c8                          rcall adminDecCost
00018c c025                          rjmp endKeypad
                                 
                                 cButton:
00018d e156                          ldi temp1, cKey
00018e 2e75                          mov keyID, temp1
00018f d305                          rcall resetNumItems
000190 c021                          rjmp endKeypad
                                 
                                 dButton: 
000191 e157                          ldi temp1, dKey
000192 2e75                          mov keyID, temp1
000193 c01e                          rjmp endKeypad
                                 
                                 admin:
000194 e048                          ldi temp, inAdmin
000195 1644                          cp currFlag, temp
000196 f089                          breq asterixDone            ; ignore any further input from '*' (which will be noise) in Admin mode
                                 
000197 2411                          clr r1
000198 14e1                          cp asterixPressed, r1       ; if button wasn't pushed before
000199 f429                          brne alreadyPressed
                                 
00019a e0c6
00019b e0d2
00019c 2744
00019d 9349
00019e 8348                          clear AsterixCounter        ; start the counter, else it'll keep adding onto counter
                                 
                                     alreadyPressed:
00019f 934f
0001a0 ef4f
0001a1 2ee4
0001a2 914f                          set_reg asterixPressed, 0xFF   ; set flag
                                 
                                 
0001a3 d0df                          rcall select_to_admin       ; check whether its time to change screens
                                 
0001a4 e042                          ldi temp, inSelect
0001a5 1654                          cp oldFlag, temp
0001a6 f009                          breq asterixDone
                                 
0001a7 d002                          rcall debounce_sleep      ; debounce the button everywhere except in select screen 
                                 
                                     asterixDone:
0001a8 2466                          clr keyPress
0001a9 c008                          rjmp endKeypad
                                 
                                 
                                 debounce_sleep:
0001aa 935f                          push temp1
0001ab e352                          ldi temp1, 50               ; debounce for 200ms
                                     startDebounce:
0001ac debc                          rcall sleep_5ms
0001ad 955a                          dec temp1
0001ae 3051                          cpi temp1, 1
0001af f7e4                          brge startDebounce
0001b0 915f                          pop temp1
0001b1 9508                          ret
                                 
                                 
                                 endKeypad:
0001b2 e043                          ldi temp, inCoin
0001b3 1644                          cp currFlag, temp
0001b4 f429                          brne coinCountCheck
                                 
0001b5 914f                          pop temp
0001b6 915f                          pop temp1
0001b7 bf5f                          out SREG, temp1
0001b8 915f                          pop temp1
                                 
0001b9 c078                          rjmp main
                                 
                                     coinCountCheck:
0001ba e046                          ldi temp, ADCCoin
0001bb 1644                          cp currFlag, temp
0001bc f431                          brne toMain
0001bd dfec                          rcall debounce_sleep
                                 
0001be 914f                          pop temp
0001bf 915f                          pop temp1
0001c0 bf5f                          out SREG, temp1
0001c1 915f                          pop temp1
                                 
0001c2 c371                          rjmp coinCount
                                 
                                     toMain:
0001c3 914f                          pop temp
0001c4 915f                          pop temp1
0001c5 bf5f                          out SREG, temp1
0001c6 915f                          pop temp1
                                 
0001c7 c06a                          rjmp main
                                 
                                 
                                 
                                 RESET: 
0001c8 e251                      	ldi temp1, high(RAMEND) 		; Initialize stack pointer
0001c9 bf5e                      	out SPH, temp1
0001ca ef5f                      	ldi temp1, low(RAMEND)
0001cb bf5d                      	out SPL, temp1
0001cc ef50                      	ldi temp1, PORTLDIR
0001cd 9350 010a                 	sts DDRL, temp1					; sets lower bits as input and upper as output
                                 
0001cf d678                      	rcall InitArrays				; initializes the Cost & Inventory arrays with appropriate values
                                 
                                 
                                 
0001d0 ef5f                      	ser temp1 						; set Port C,B & D as output - reset all bits to 0 (ser = set all bits in register)
0001d1 b957                      	out DDRC, temp1 
0001d2 b95d                      	out DDRE, temp1
0001d3 b954                      	out DDRB, temp1
0001d4 bb53                      	out DDRG, temp1
                                 
0001d5 ef5f                      	ser temp1
0001d6 bb54                      	out PORTG, temp1
                                 
0001d7 ef40                          ldi temp, PORTLDIR
0001d8 9340 010a                     sts DDRL, temp            		; sets lower bits as input and upper as output
                                 
0001da ef0f                          ser r16
0001db bb00                          out DDRF, r16
0001dc b901                          out DDRA, r16
0001dd 2700                          clr r16
0001de bb01                          out PORTF, r16
0001df b902                          out PORTA, r16              	; setting PORTA & PORTF as output
                                 
0001e0 ef4f                      	ser temp 						; set Port C as output - reset all bits to 0 (ser = set all bits in register)
0001e1 b947                      	out DDRC, temp 
                                 
0001e2 2744                      	clr temp
0001e3 b94a                      	out DDRD, temp					; set PORTD (external interrupts) as input
                                 
0001e4 e043                      	ldi temp, (1 << INT0) | (1 << INT1)
0001e5 bb4d                      	out EIMSK, temp
                                 
0001e6 930f
0001e7 e308
0001e8 de56
0001e9 de65
0001ea 910f                          do_lcd_command 0b00111000 		; 2x5x7 (2 lines, 5x7 is the font)
0001eb de7d                          rcall sleep_5ms
0001ec 930f
0001ed e308
0001ee de50
0001ef de5f
0001f0 910f                          do_lcd_command 0b00111000 		; 2x5x7
0001f1 de6e                          rcall sleep_1ms
0001f2 930f
0001f3 e308
0001f4 de4a
0001f5 de59
0001f6 910f                          do_lcd_command 0b00111000 		; 2x5x7
0001f7 930f
0001f8 e308
0001f9 de45
0001fa de54
0001fb 910f                          do_lcd_command 0b00111000 		; 2x5x7
0001fc 930f
0001fd e008
0001fe de40
0001ff de4f
000200 910f                          do_lcd_command 0b00001000 		; display off?
000201 930f
000202 e001
000203 de3b
000204 de4a
000205 910f                          do_lcd_command 0b00000001 		; clear display
000206 930f
000207 e006
000208 de36
000209 de45
00020a 910f                          do_lcd_command 0b00000110 		; increment, no display shift
00020b 930f
00020c e00e
00020d de31
00020e de40
00020f 910f                          do_lcd_command 0b00001110 		; Cursor on, bar, no blink
                                 
000210 934f
000211 e041
000212 2e44
000213 914f                      	set_reg currFlag, inStart
000214 2455                      	clr oldFlag
000215 e0c2
000216 e0d2
000217 2744
000218 9349
000219 8348                      	clear DisplayCounter
00021a e0c8
00021b e0d2
00021c 2744
00021d 9349
00021e 8348                      	clear SoundCounter
00021f 24ee                      	clr asterixPressed
                                 
000220 e040                          ldi temp, 0b00000000
000221 bd44                          out TCCR0A, temp
000222 e042                          ldi temp, 0b00000010
000223 bd45                          out TCCR0B, temp        ; Prescaling value=8
000224 e041                          ldi temp, 1<<TOIE0      ; = 128 microseconds
000225 9340 006e                     sts TIMSK0, temp        ; T/C0 interrupt enable
                                 
000227 2499                      	clr coinsToReturn
                                 
                                 	// REFS0: sets up voltage reference, 0b01 provides the reference with the best range
                                 	// setting ADLAR to 1 left aligns the 10 output bits within the 16 bit output register
                                 	// MUX0 to MUX5 choose the input pin/mode/gain. 0b10000 chooses PK8 on the board
                                 	// ADIE enables the ADC interrupt, which interrupts when a conversion is finished
                                 	// ADPS0 chooses the ADC clock divider. 0b111 uses a 128 divider to get a 125 kHz ADC
                                 	//      clock which is within the recommended range of 50 - 200 kHz
000228 e440                      	ldi temp, (0b01 << REFS0) | (0 << ADLAR) | (0 << MUX0)
000229 9340 007c                 	sts ADMUX, temp
                                 
00022b e048                      	ldi temp, (1 << MUX5)
00022c 9340 007b                 	sts ADCSRB, temp
                                 
00022e e84f                      	ldi temp, (1 << ADEN) | (1 << ADIE) | (0b111 << ADPS0) 
00022f 9340 007a                 	sts ADCSRA, temp
                                 
000231 9478                      	sei
                                 
                                 
                                 
                                 main:
000232 1445                      	cp currFlag, oldFlag
000233 f419                      	brne update				; screen update needed 
                                 	
000234 ef4f                      	ldi temp, 0xFF
000235 1664                      	cp keyPress, temp
000236 f4b9                      	brne end				; if key not pressed no update needed 
                                 							; else if is pressed then one of the screens might need updating
                                 	update:
000237 2c54                      	mov oldFlag, currFlag	; update flags
                                 
000238 2d44                      	mov temp, currFlag
                                 	
000239 3041                      	cpi temp, inStart		; checking which screen to update to
00023a f409                      	brne checkAdmin
00023b d565                      	rcall startScreen
                                 checkAdmin:
00023c 3048                      	cpi temp, inAdmin		; checking which screen to update to
00023d f409                      	brne checkSelect
00023e d06f                      	rcall adminScreen
                                 checkSelect:
00023f 3042                      	cpi temp, inSelect
000240 f409                      	brne checkEmpty
000241 d49b                      	rcall selectScreen		
                                 checkEmpty:
000242 3044                      	cpi temp, inEmpty
000243 f409                      	brne checkCoin
000244 d427                      	rcall emptyScreen
                                 checkCoin:
000245 3043                      	cpi temp, inCoin
000246 f409                      	brne checkReturn
000247 d2c4                      	rcall coinScreen
                                 checkReturn:
000248 3045                      	cpi temp, inReturn
000249 f409                      	brne checkDeliver
00024a d2ac                      	rcall returnScreen
                                 checkDeliver:
00024b 3047                      	cpi temp, inDeliver
00024c f409                      	brne end
00024d d3b0                      	rcall deliverScreen
                                 	
                                 end:
00024e cee6                      	rjmp init_loop
                                 
                                 	
                                 checkCoins:
00024f 934f                          push temp
000250 b74f                          in temp, SREG
000251 934f                          push temp
                                 
000252 e046                      	ldi temp, ADCCoin
000253 1644                      	cp currFlag, temp
000254 f461                      	brne endFunction
                                 
000255 2744                      	clr temp
000256 16a4                      	cp coinsEntered, temp
000257 f429                      	brne retCoin
                                 
000258 934f
000259 e042
00025a 2e44
00025b 914f                      	set_reg currFlag, inSelect			; no coins have been entered
00025c c04d                      	rjmp endF
                                 
                                 	retCoin:							; coins have been entered
00025d 934f
00025e e045
00025f 2e44
000260 914f                      	set_reg currFlag, inReturn
                                 
                                 	endFunction:
000261 c048                      	rjmp endF	
                                 
                                 start_to_select:
000262 934f                          push temp
000263 b74f                          in temp, SREG
000264 934f                          push temp
                                 
000265 2d44                          mov temp, currFlag
000266 3041                          cpi temp, inStart              ; checking whether the start screen is open
000267 f7c9                          brne endFunction
                                                                 ; not in start screen, so keep going
                                     
000268 934f
000269 e042
00026a 2e44
00026b 914f                          set_reg currFlag, inSelect
00026c 934f
00026d 2744
00026e 2e64
00026f 914f                      	clr_reg keyPress					; ignore this key press
000270 c039                      	rjmp endF
                                 
                                 empty_to_select:
000271 934f                          push temp
000272 b74f                          in temp, SREG
000273 934f                          push temp
                                 
000274 2d44                          mov temp, currFlag
000275 3044                          cpi temp, inEmpty              ; checking whether the empty screen is open
000276 f599                          brne endF 
                                 									; not in empty screen, so keep going
000277 2744                      	clr temp
000278 b948                      	out PORTC, temp                     
000279 b94e                      	out PORTE, temp
                                     
00027a 934f
00027b e042
00027c 2e44
00027d 914f                          set_reg currFlag, inSelect
00027e 934f
00027f 2744
000280 2e64
000281 914f                      	clr_reg keyPress					; ignore this key press
000282 c027                      	rjmp endF
                                 
                                 select_to_admin:
000283 934f                          push temp
000284 b74f                          in temp, SREG
000285 934f                          push temp
000286 93af                      	push r26
000287 93bf                      	push r27
                                 
000288 2d45                          mov temp, oldFlag
000289 3042                          cpi temp, inSelect              ; checking whether the empty screen is open
00028a f4f9                          brne endF 
                                 
00028b 91a0 0206                 	lds r26, AsterixCounter
00028d 91b0 0207                     lds r27, AsterixCounter+1
                                 
00028f 34a0                      	cpi r26, low(5000*INTS_PER_MS)        
000290 e94c                          ldi temp, high(5000*INTS_PER_MS) 
000291 07b4                          cpc r27, temp
                                 
000292 91bf                      	pop r27
000293 91af                      	pop r26
                                 
000294 f4a9                      	brne endF						; button not held down for 5 seconds yet
                                 
                                 									; not in empty screen, so keep going    
000295 934f
000296 e048
000297 2e44
000298 914f                          set_reg currFlag, inAdmin
000299 934f
00029a 2744
00029b 2e64
00029c 914f                      	clr_reg keyPress					; ignore this key press
00029d c00c                      	rjmp endF
                                 
                                 deliver_to_select:
00029e 934f                      	push temp
00029f b74f                          in temp, SREG
0002a0 934f                      	push temp
                                 
0002a1 2d44                      	mov temp, currFlag
0002a2 3047                          cpi temp, inDeliver              ; checking whether the empty screen is open
0002a3 f431                          brne endF 
                                 
0002a4 934f
0002a5 e042
0002a6 2e44
0002a7 914f                          set_reg currFlag, inSelect
0002a8 e040                      	ldi temp, 0
0002a9 b94e                      	out PORTE, temp     ; turn off moter 
                                 
                                     endF:
0002aa 914f                          pop temp
0002ab bf4f                          out SREG, temp
0002ac 914f                          pop temp
0002ad 9508                          ret 
                                 
                                 .include "modules/AdminScreen.asm"
                                 
                                 ; Project - Vending Machine
                                 ;	
                                 ; Admin Screen
                                 
                                 adminScreen:
0002ae 934f                        push temp
0002af b74f                        in temp, SREG
0002b0 934f                        push temp
0002b1 935f                        push temp1
                                 
                                 
0002b2 ef5f                        ser temp1
0002b3 1665                        cp keyPress, temp1
                                   
                                 
0002b4 f011                        breq notDefault
                                 
                                   defaultItem:
0002b5 e041                        ldi temp, 1
0002b6 2ed4                        mov currItem, temp
                                 
                                   notDefault:						; a key has been pressed so assume item has been changed if needed
                                 
                                   //out PORTC, currItem
                                 
0002b7 930f
0002b8 e001
0002b9 dd85
0002ba dd94
0002bb 910f                        do_lcd_command 0b00000001 		; clear display
0002bc 930f
0002bd e006
0002be dd80
0002bf dd8f
0002c0 910f                        do_lcd_command 0b00000110 		; increment, no display shift
0002c1 930f
0002c2 e00e
0002c3 dd7b
0002c4 dd8a
0002c5 910f                        do_lcd_command 0b00001110 		; Cursor on, bar, no blink
                                 
0002c6 930f
0002c7 e401
0002c8 dd7d
0002c9 dd85
0002ca 910f                        do_lcd_data_i 'A' 
0002cb 930f
0002cc e604
0002cd dd78
0002ce dd80
0002cf 910f                        do_lcd_data_i 'd' 
0002d0 930f
0002d1 e60d
0002d2 dd73
0002d3 dd7b
0002d4 910f                        do_lcd_data_i 'm' 
0002d5 930f
0002d6 e609
0002d7 dd6e
0002d8 dd76
0002d9 910f                        do_lcd_data_i 'i' 
0002da 930f
0002db e60e
0002dc dd69
0002dd dd71
0002de 910f                        do_lcd_data_i 'n' 
0002df 930f
0002e0 e200
0002e1 dd64
0002e2 dd6c
0002e3 910f                        do_lcd_data_i ' ' 
0002e4 930f
0002e5 e60d
0002e6 dd5f
0002e7 dd67
0002e8 910f                        do_lcd_data_i 'm' 
0002e9 930f
0002ea e60f
0002eb dd5a
0002ec dd62
0002ed 910f                        do_lcd_data_i 'o' 
0002ee 930f
0002ef e604
0002f0 dd55
0002f1 dd5d
0002f2 910f                        do_lcd_data_i 'd' 
0002f3 930f
0002f4 e605
0002f5 dd50
0002f6 dd58
0002f7 910f                        do_lcd_data_i 'e' 
0002f8 930f
0002f9 e200
0002fa dd4b
0002fb dd53
0002fc 910f                        do_lcd_data_i ' '
                                 
0002fd 2d0d                        mov r16, currItem
0002fe dd70                        rcall print_digits 
                                 
0002ff 930f
000300 ec00
000301 dd3d
000302 dd4c
000303 910f                        do_lcd_command 0b11000000  		; break to the next line 
                                 
000304 2d5d                        mov temp1, currItem
000305 93af
000306 93bf
000307 935f
000308 934f
000309 b74f
00030a 934f
00030b e0ac
00030c e0b2
00030d 3051
00030e f021
00030f 5051
000310 9611
000311 940c 030d
000313 2700
000314 910c
000315 914f
000316 bf4f
000317 914f
000318 915f
000319 91bf
00031a 91af                        get_element temp1, Inventory, r16
00031b dd53                        rcall print_digits 				; print inventory
                                 
00031c d02a                        rcall addSpaces					; print spaces to move cost to the end of line
                                 
00031d 2d5d                        mov temp1, currItem
00031e 93af
00031f 93bf
000320 935f
000321 934f
000322 b74f
000323 934f
000324 e1a5
000325 e0b2
000326 3051
000327 f021
000328 5051
000329 9611
00032a 940c 0326
00032c 2700
00032d 910c
00032e 914f
00032f bf4f
000330 914f
000331 915f
000332 91bf
000333 91af                        get_element temp1, Cost , r16
000334 dd3a                        rcall print_digits 				; print inventory
                                 
000335 d188                        rcall AdminUpdateLEDs
000336 2466                        clr keyPress
                                 
000337 915f                        pop temp1
000338 914f                        pop temp
000339 bf4f                        out SREG, temp
00033a 914f                        pop temp
                                 
00033b 9508                        ret 
                                 
                                 
                                 updateAdminItem:
00033c 934f                      	push temp
00033d b74f                      	in temp, SREG
00033e 934f                      	push temp
                                 
00033f e048                      	ldi temp, inAdmin
000340 1654                      	cp oldFlag, temp
000341 f409                      	brne noUpdate
                                 
000342 2cd7                      	mov currItem, keyID
                                 
                                 	noUpdate:
000343 914f                        	pop temp
000344 bf4f                       	out SREG, temp
000345 914f                        	pop temp
                                 
000346 9508                        	ret
                                 
                                 addSpaces:
000347 934f                      	push temp
000348 b74f                      	in temp, SREG
000349 934f                      	push temp
                                 
00034a 930f
00034b e200
00034c dcf9
00034d dd01
00034e 910f                      	do_lcd_data_i ' ' 
00034f 930f
000350 e200
000351 dcf4
000352 dcfc
000353 910f                      	do_lcd_data_i ' ' 
000354 930f
000355 e200
000356 dcef
000357 dcf7
000358 910f                      	do_lcd_data_i ' ' 
000359 930f
00035a e200
00035b dcea
00035c dcf2
00035d 910f                      	do_lcd_data_i ' ' 
00035e 930f
00035f e200
000360 dce5
000361 dced
000362 910f                      	do_lcd_data_i ' ' 
000363 930f
000364 e200
000365 dce0
000366 dce8
000367 910f                      	do_lcd_data_i ' ' 
000368 930f
000369 e200
00036a dcdb
00036b dce3
00036c 910f                      	do_lcd_data_i ' ' 
00036d 930f
00036e e200
00036f dcd6
000370 dcde
000371 910f                      	do_lcd_data_i ' ' 
000372 930f
000373 e200
000374 dcd1
000375 dcd9
000376 910f                      	do_lcd_data_i ' '  
000377 930f
000378 e204
000379 dccc
00037a dcd4
00037b 910f                      	do_lcd_data_i '$'
                                 
00037c 914f                        	pop temp
00037d bf4f                       	out SREG, temp
00037e 914f                        	pop temp 
                                 
00037f 9508                        	ret
                                 
                                 exitAdmin:
000380 934f                      	push temp
000381 b74f                      	in temp, SREG
000382 934f                      	push temp	
                                 
000383 e048                      	ldi temp, inAdmin
000384 1654                      	cp oldFlag, temp
                                 
000385 f439                      	brne noAdminExit
                                 
000386 934f
000387 e042
000388 2e44
000389 914f                      	set_reg currFlag, inSelect
                                 
00038a 2755                      	clr temp1
00038b b958                      	out PORTC, temp1
00038c b95e                      	out PORTE, temp1					; turn off LEDs
                                 
                                 	noAdminExit:
00038d 914f                        	pop temp
00038e bf4f                       	out SREG, temp
00038f 914f                        	pop temp 
                                 
000390 9508                        	ret
                                 
                                 adminRemoveItem:
000391 934f                      	push temp
000392 b74f                      	in temp, SREG
000393 934f                      	push temp	
000394 930f                          push r16
000395 931f                          push r17
                                 
000396 e048                      	ldi temp, inAdmin
000397 1654                      	cp oldFlag, temp
000398 f599                      	brne endRemove
                                 
000399 934f
00039a ef4f
00039b 2e64
00039c 914f                          set_reg keyPress, 0xFF					; set flag to update the screen
                                 
00039d 2d1d                          mov r17, currItem
00039e 93af
00039f 93bf
0003a0 931f
0003a1 934f
0003a2 b74f
0003a3 934f
0003a4 e0ac
0003a5 e0b2
0003a6 3011
0003a7 f021
0003a8 5011
0003a9 9611
0003aa 940c 03a6
0003ac 2700
0003ad 910c
0003ae 914f
0003af bf4f
0003b0 914f
0003b1 911f
0003b2 91bf
0003b3 91af                          get_element r17, Inventory, r16
                                 
0003b4 3000                          cpi r16, 0
0003b5 f0b1                          breq endRemove
                                 
0003b6 950a                          dec r16
0003b7 93af
0003b8 93bf
0003b9 931f
0003ba 934f
0003bb b74f
0003bc 934f
0003bd e0ac
0003be e0b2
0003bf 3011
0003c0 f021
0003c1 5011
0003c2 9611
0003c3 940c 03bf
0003c5 930c
0003c6 914f
0003c7 bf4f
0003c8 914f
0003c9 911f
0003ca 91bf
0003cb 91af                          set_element r17, Inventory, r16
                                 
                                     endRemove:
0003cc 911f                          pop r17
0003cd 910f                          pop r16
0003ce 914f                        	pop temp
0003cf bf4f                       	out SREG, temp
0003d0 914f                        	pop temp 
0003d1 9508                      ret
                                 
                                 adminAddItem:
0003d2 934f                      	push temp
0003d3 b74f                      	in temp, SREG
0003d4 934f                      	push temp	
0003d5 930f                          push r16
0003d6 931f                          push r17
                                 
0003d7 e048                      	ldi temp, inAdmin
0003d8 1654                      	cp oldFlag, temp
0003d9 f599                      	brne endAdd
                                 
0003da 934f
0003db ef4f
0003dc 2e64
0003dd 914f                          set_reg keyPress, 0xFF					; set flag to update the screen
                                 
0003de 2d1d                          mov r17, currItem
0003df 93af
0003e0 93bf
0003e1 931f
0003e2 934f
0003e3 b74f
0003e4 934f
0003e5 e0ac
0003e6 e0b2
0003e7 3011
0003e8 f021
0003e9 5011
0003ea 9611
0003eb 940c 03e7
0003ed 2700
0003ee 910c
0003ef 914f
0003f0 bf4f
0003f1 914f
0003f2 911f
0003f3 91bf
0003f4 91af                          get_element r17, Inventory, r16
                                 
0003f5 3f0f                          cpi r16, 255
0003f6 f0b1                          breq endAdd
                                 
0003f7 9503                          inc r16
0003f8 93af
0003f9 93bf
0003fa 931f
0003fb 934f
0003fc b74f
0003fd 934f
0003fe e0ac
0003ff e0b2
000400 3011
000401 f021
000402 5011
000403 9611
000404 940c 0400
000406 930c
000407 914f
000408 bf4f
000409 914f
00040a 911f
00040b 91bf
00040c 91af                          set_element r17, Inventory, r16
                                 
                                     endAdd:
00040d 911f                          pop r17
00040e 910f                          pop r16
00040f 914f                        	pop temp
000410 bf4f                       	out SREG, temp
000411 914f                        	pop temp 
000412 9508                      ret
                                 
                                 adminIncCost:
000413 934f                      	push temp
000414 b74f                      	in temp, SREG
000415 934f                      	push temp	
000416 930f                          push r16
000417 931f                          push r17
                                 
000418 e048                      	ldi temp, inAdmin
000419 1654                      	cp oldFlag, temp
00041a f599                      	brne endIncCost
                                 
00041b 934f
00041c ef4f
00041d 2e64
00041e 914f                          set_reg keyPress, 0xFF					; set flag to update the screen
                                 
00041f 2d1d                          mov r17, currItem
000420 93af
000421 93bf
000422 931f
000423 934f
000424 b74f
000425 934f
000426 e1a5
000427 e0b2
000428 3011
000429 f021
00042a 5011
00042b 9611
00042c 940c 0428
00042e 2700
00042f 910c
000430 914f
000431 bf4f
000432 914f
000433 911f
000434 91bf
000435 91af                          get_element r17, Cost, r16
                                 
000436 3003                          cpi r16, 3
000437 f0b1                          breq endIncCost
                                 
000438 9503                          inc r16
000439 93af
00043a 93bf
00043b 931f
00043c 934f
00043d b74f
00043e 934f
00043f e1a5
000440 e0b2
000441 3011
000442 f021
000443 5011
000444 9611
000445 940c 0441
000447 930c
000448 914f
000449 bf4f
00044a 914f
00044b 911f
00044c 91bf
00044d 91af                          set_element r17, Cost, r16
                                 
                                     endIncCost:
00044e 911f                          pop r17
00044f 910f                          pop r16
000450 914f                        	pop temp
000451 bf4f                       	out SREG, temp
000452 914f                        	pop temp 
000453 9508                      ret
                                 
                                 adminDecCost:
000454 934f                      	push temp
000455 b74f                      	in temp, SREG
000456 934f                      	push temp	
000457 930f                          push r16
000458 931f                          push r17
                                 
000459 e048                      	ldi temp, inAdmin
00045a 1654                      	cp oldFlag, temp
00045b f599                      	brne endDecCost
                                 
00045c 934f
00045d ef4f
00045e 2e64
00045f 914f                          set_reg keyPress, 0xFF					; set flag to update the screen
                                 
000460 2d1d                          mov r17, currItem
000461 93af
000462 93bf
000463 931f
000464 934f
000465 b74f
000466 934f
000467 e1a5
000468 e0b2
000469 3011
00046a f021
00046b 5011
00046c 9611
00046d 940c 0469
00046f 2700
000470 910c
000471 914f
000472 bf4f
000473 914f
000474 911f
000475 91bf
000476 91af                          get_element r17, Cost, r16
                                 
000477 3001                          cpi r16, 1
000478 f0b1                          breq endDecCost
                                 
000479 950a                          dec r16
00047a 93af
00047b 93bf
00047c 931f
00047d 934f
00047e b74f
00047f 934f
000480 e1a5
000481 e0b2
000482 3011
000483 f021
000484 5011
000485 9611
000486 940c 0482
000488 930c
000489 914f
00048a bf4f
00048b 914f
00048c 911f
00048d 91bf
00048e 91af                          set_element r17, Cost, r16
                                 
                                     endDecCost:
00048f 911f                          pop r17
000490 910f                          pop r16
000491 914f                        	pop temp
000492 bf4f                       	out SREG, temp
000493 914f                        	pop temp 
000494 9508                      ret
                                 
                                 resetNumItems:
000495 934f                      	push temp
000496 b74f                      	in temp, SREG
000497 934f                      	push temp	
000498 930f                          push r16
000499 931f                          push r17
                                 
00049a e048                      	ldi temp, inAdmin
00049b 1654                      	cp oldFlag, temp
00049c f4d9                      	brne endReset
                                 
00049d 934f
00049e ef4f
00049f 2e64
0004a0 914f                          set_reg keyPress, 0xFF					; set flag to update the screen
                                 
0004a1 2d1d                          mov r17, currItem
0004a2 2700                          clr r16
0004a3 93af
0004a4 93bf
0004a5 931f
0004a6 934f
0004a7 b74f
0004a8 934f
0004a9 e0ac
0004aa e0b2
0004ab 3011
0004ac f021
0004ad 5011
0004ae 9611
0004af 940c 04ab
0004b1 930c
0004b2 914f
0004b3 bf4f
0004b4 914f
0004b5 911f
0004b6 91bf
0004b7 91af                          set_element r17, Inventory, r16
                                 
                                     endReset:
0004b8 911f                          pop r17
0004b9 910f                          pop r16
0004ba 914f                        	pop temp
0004bb bf4f                       	out SREG, temp
0004bc 914f                        	pop temp 
0004bd 9508                      ret
                                 
                                 AdminUpdateLEDs:
0004be 934f                      	push temp
0004bf b74f                      	in temp, SREG
0004c0 934f                      	push temp
0004c1 931f                      	push r17
0004c2 935f                      	push temp1
                                 
0004c3 2411                      	clr r1
0004c4 e040                      	ldi temp, 0
                                 
0004c5 2d1d                      	mov r17, currItem
0004c6 93af
0004c7 93bf
0004c8 931f
0004c9 934f
0004ca b74f
0004cb 934f
0004cc e0ac
0004cd e0b2
0004ce 3011
0004cf f021
0004d0 5011
0004d1 9611
0004d2 940c 04ce
0004d4 2755
0004d5 915c
0004d6 914f
0004d7 bf4f
0004d8 914f
0004d9 911f
0004da 91bf
0004db 91af                      	get_element r17, Inventory, temp1
0004dc 935f                      	push temp1
                                 
                                 	AdminLEDloop:
0004dd 1615                      	cp r1, temp1
0004de f021                      	breq LEDFinish
                                 
0004df 0f44                      		lsl temp
0004e0 9543                      		inc temp
0004e1 955a                      		dec temp1
0004e2 cffa                      		rjmp AdminLEDloop
                                 	LEDFinish:
0004e3 b948                      		out PORTC, temp
                                 	
0004e4 915f                      	pop temp1
                                 	
0004e5 3059                      	cpi temp1, 9
                                 
0004e6 f040                      	brlo noOtherLights
0004e7 f009                      	breq oneLight
0004e8 c003                      	rjmp twoLights
                                 
                                 	oneLight:
0004e9 e058                      	ldi temp1, 0b00001000
0004ea 940c 04f0                 	jmp printLights
                                 
                                 	twoLights:
0004ec e258                      	ldi temp1, 0b00101000
0004ed 940c 04f0                 	jmp printLights
                                 
                                 	noOtherLights:
0004ef 2755                      	clr temp1
                                 
                                 	printLights:
0004f0 b95e                      	out PORTE, temp1
                                 
                                 	endLEDUpdate:
0004f1 915f                      	pop temp1
0004f2 911f                      	pop r17
0004f3 914f                      	pop temp
0004f4 bf4f                      	out SREG, temp
0004f5 914f                      	pop temp
                                 
                                 .include "modules/CoinReturn.asm"
0004f6 9508                      
                                 ===================================================================
                                 COMP2121                                                        
                                 Project - Vending Machine
                                 CoinReturn
                                 
                                 
                                 Sets up system to return the coins entered
                                 ===================================================================
                                 */
                                 
                                 returnScreen:
0004f7 934f                        push temp
0004f8 b74f                        in temp, SREG
0004f9 934f                        push temp
                                 
0004fa 2c9a                        mov coinsToReturn, coinsEntered           ; store the coins entered as coins that have to be returned
                                 
0004fb e0c4
0004fc e0d2
0004fd 2744
0004fe 9349
0004ff 8348                        clear ReturnCounter
                                   
000500 ed50                        ldi temp1, turnMotOn
000501 b95e                        out PORTE, temp1                          ; turn the motor on to begin returning
                                 
000502 934f
000503 e042
000504 2e44
000505 914f                        set_reg currFlag, inSelect                ; systems changes back to select mode
                                 
000506 2744                        clr temp
000507 b948                        out PORTC, temp                           ; turns off any previously lit LEDs
                                 
000508 914f                        pop temp
000509 bf4f                        out SREG, temp
00050a 914f                        pop temp
                                   
00050b 9508                        ret
                                 .include "modules/CoinScreen.asm"
                                 
                                 ; Project - Vending Machine
                                 ;	
                                 ; Coin Screen
                                 ; - takes in coin
                                 
                                 
                                 /*TODO: at the end of coin count, jump to keypad to chack for "#".
                                 		If "#" not pressed then (check flag and) rcall coinCount
                                 		Else change flag and jmp to main
                                 
                                 		What happens when coins are finished?
                                 */
                                 
                                 
                                 .equ potMax = 2
                                 .equ potMin = 9
                                 .equ potMid = 34
                                 
                                 .macro cpMax
                                 	push r16
                                 	ldi r16, low(0x3FD)
                                   	cp ADCLow, r16
                                 	ldi r16, high(0x3FD)
                                   	cpc ADCHigh, r16
                                 .endmacro
                                 
                                 .macro cpMin
                                 	push r16
                                 	ldi r16, 0x001				; need a threshold for lower bound
                                   	cp ADCLow, r16
                                   	clr r16
                                   	cpc ADCHigh, r16
                                   	pop r16
                                 .endmacro
                                 
                                 
                                 coinScreen:
00050c 2d57                      	mov  temp1, keyID 
00050d 93af
00050e 93bf
00050f 935f
000510 934f
000511 b74f
000512 934f
000513 e1a5
000514 e0b2
000515 3051
000516 f021
000517 5051
000518 9611
000519 940c 0515
00051b 24bb
00051c 90bc
00051d 914f
00051e bf4f
00051f 914f
000520 915f
000521 91bf
000522 91af                      	get_element temp1, Cost, coinsRequired
000523 24aa                      	clr coinsEntered
                                 
000524 d039                      	rcall printCoinScreen
                                 
000525 934f
000526 e242
000527 2e84
000528 914f                        	set_reg potPos, potMid
                                 
000529 e0ca
00052a e0d2
00052b 2744
00052c 9349
00052d 8348                        	clear ADCCounter
00052e 934f
00052f e046
000530 2e44
000531 914f                      	set_reg currFlag, ADCCoin				; notify all functions that coins are being counted
000532 d001                        	rcall coinCount
                                 
                                 	; remember to move value outta r16 to different one else it'll be overwritten by keypad
000533 9508                      ret
                                 
                                 
                                 
                                   	
                                 coinCount:
                                   	; the timer constantly polls the flag so when we're in the coin screen, it'll start
                                   	; enabling the ADC reader which in turn updates temp and temp1 with the
                                   	; low and high bytes respectively
                                  		
                                 		
000534 930f
000535 ef0d
000536 1760
000537 e003
000538 0770                      	  	cpMax								; check if POT at max angle
000539 f4dc                      	  	brge highSet
                                 
00053a 930f
00053b e001
00053c 1760
00053d 2700
00053e 0770
00053f 910f                      	  	cpMin								; check if POT at min angle	
000540 f008                      	  	brlo lowSet
                                 	  	
000541 cbf3                      	  	rjmp init_loop						; POT somewhere in between
                                 
                                 	  	lowSet:
000542 e012                      			ldi r17, potMax
000543 1681                      			cp potPos, r17					
                                 
000544 f459                      			brne noCoin						; transitioned from high to low so coin entered
                                 
000545 94a3                      			inc coinsEntered
000546 d0a3                      				rcall updateLEDs
000547 14ab                      	 			cp coinsEntered, coinsRequired
000548 f431                      				brne notDone
                                 
000549 d06e                      				rcall removeItem
00054a 934f
00054b e047
00054c 2e44
00054d 914f                      				set_reg currFlag, inDeliver			
00054e cce3                      				rjmp main
                                 
                                 			notDone:
00054f d00e                      	  		rcall printCoinScreen			; update screen	
                                 
                                 			noCoin:							; else there was no coin entered
000550 934f
000551 e049
000552 2e84
000553 914f                      			set_reg potPos, potMin			; set flag appropriately
                                 
000554 cbe0                      	  		rjmp init_loop
                                 
                                 		highSet:
000555 e019                      			ldi r17, potMin
000556 1681                      			cp potPos, r17					; if we didn't transition from low then ignore
                                 
000557 f421                      			brne ignore
                                 			
000558 934f
000559 e042
00055a 2e84
00055b 914f                      			set_reg potPos, potMax			; otherwise register the high angle
                                 			
                                 
                                 			ignore:
00055c cbd8                      			rjmp init_loop
00055d 9508                      ret
                                 
                                 
                                 printCoinScreen:
00055e 930f
00055f e001
000560 dade
000561 daed
000562 910f                      	do_lcd_command 0b00000001 				; clear display
000563 930f
000564 e006
000565 dad9
000566 dae8
000567 910f                      	do_lcd_command 0b00000110 				; increment, no display shift
000568 930f
000569 e00e
00056a dad4
00056b dae3
00056c 910f                      	do_lcd_command 0b00001110 				; Cursor on, bar, no blink
                                 
00056d 930f
00056e e409
00056f dad6
000570 dade
000571 910f                        	do_lcd_data_i 'I' 
000572 930f
000573 e60e
000574 dad1
000575 dad9
000576 910f                        	do_lcd_data_i 'n' 
000577 930f
000578 e703
000579 dacc
00057a dad4
00057b 910f                      	do_lcd_data_i 's' 
00057c 930f
00057d e605
00057e dac7
00057f dacf
000580 910f                      	do_lcd_data_i 'e' 
000581 930f
000582 e702
000583 dac2
000584 daca
000585 910f                      	do_lcd_data_i 'r' 
000586 930f
000587 e704
000588 dabd
000589 dac5
00058a 910f                      	do_lcd_data_i 't' 
00058b 930f
00058c e200
00058d dab8
00058e dac0
00058f 910f                      	do_lcd_data_i ' ' 
000590 930f
000591 e403
000592 dab3
000593 dabb
000594 910f                      	do_lcd_data_i 'C' 
000595 930f
000596 e60f
000597 daae
000598 dab6
000599 910f                      	do_lcd_data_i 'o' 
00059a 930f
00059b e609
00059c daa9
00059d dab1
00059e 910f                      	do_lcd_data_i 'i' 
00059f 930f
0005a0 e60e
0005a1 daa4
0005a2 daac
0005a3 910f                      	do_lcd_data_i 'n' 
0005a4 930f
0005a5 e703
0005a6 da9f
0005a7 daa7
0005a8 910f                      	do_lcd_data_i 's' 
                                 
0005a9 930f
0005aa ec00
0005ab da93
0005ac daa2
0005ad 910f                        	do_lcd_command 0b11000000  				; break to the next line 
                                 
0005ae 924f                        	push currFlag
0005af 934f
0005b0 e043
0005b1 2e44
0005b2 914f                        	set_reg currFlag, inCoin				; pause the ADC so that the temp registers won't be updated		
0005b3 2d0b                        	mov r16, coinsRequired	
0005b4 190a                        	sub r16, coinsEntered
0005b5 dab9                        	rcall print_digits ; row = item id 
0005b6 904f                        	pop currFlag							; resume the ADC operation		
                                 
0005b7 9508                        	ret
                                 
                                 removeItem:
0005b8 930f                          push r16
0005b9 931f                          push r17
0005ba 2d17                          mov r17, keyID
0005bb 93af
0005bc 93bf
0005bd 931f
0005be 934f
0005bf b74f
0005c0 934f
0005c1 e0ac
0005c2 e0b2
0005c3 3011
0005c4 f021
0005c5 5011
0005c6 9611
0005c7 940c 05c3
0005c9 2700
0005ca 910c
0005cb 914f
0005cc bf4f
0005cd 914f
0005ce 911f
0005cf 91bf
0005d0 91af                          get_element r17, Inventory, r16
0005d1 950a                          dec r16
0005d2 93af
0005d3 93bf
0005d4 931f
0005d5 934f
0005d6 b74f
0005d7 934f
0005d8 e0ac
0005d9 e0b2
0005da 3011
0005db f021
0005dc 5011
0005dd 9611
0005de 940c 05da
0005e0 930c
0005e1 914f
0005e2 bf4f
0005e3 914f
0005e4 911f
0005e5 91bf
0005e6 91af                          set_element r17, Inventory, r16
0005e7 911f                          pop r17
0005e8 910f                          pop r16
0005e9 9508                      	ret
                                 
                                 updateLEDS:
0005ea 934f                      	push temp
0005eb b74f                      	in temp, SREG
0005ec 934f                      	push temp
0005ed 92af                      	push coinsEntered
0005ee 935f                      	push temp1
0005ef 2411                      	clr r1
                                 
0005f0 e040                      	ldi temp, 0
                                 
                                 	LEDloop:
0005f1 141a                      	cp r1, coinsEntered
0005f2 f021                      	breq updateFinish
                                 
0005f3 0f44                      		lsl temp
0005f4 9543                      		inc temp
0005f5 94aa                      		dec coinsEntered
0005f6 cffa                      		rjmp LEDloop
                                 
                                 	updateFinish:
0005f7 b948                      		out PORTC, temp
                                 
0005f8 915f                      	pop temp1
0005f9 90af                      	pop coinsEntered
0005fa 914f                      	pop temp
0005fb bf4f                      	out SREG, temp
0005fc 914f                      	pop temp
                                 
0005fd 9508                      	ret
                                 .include "modules/DeliverScreen.asm"
                                 
                                 ===================================================================
                                 COMP2121                                                        
                                 Project - Vending Machine
                                 Deliver Screen
                                 
                                 
                                 Delivers the item requested by user and updates inventory
                                 ===================================================================
                                 */
                                 
                                 
                                 deliverScreen:
0005fe 934f                        push temp 
0005ff b74f                        in temp, SREG 
000600 934f                        push temp 
                                 
000601 930f
000602 e001
000603 da3b
000604 da4a
000605 910f                        do_lcd_command 0b00000001 		      ; clear display
000606 930f
000607 e006
000608 da36
000609 da45
00060a 910f                        do_lcd_command 0b00000110 		      ; increment, no display shift
00060b 930f
00060c e00e
00060d da31
00060e da40
00060f 910f                        do_lcd_command 0b00001110 		      ; Cursor on, bar, no blink
                                 
000610 930f
000611 e404
000612 da33
000613 da3b
000614 910f                        do_lcd_data_i 'D' 
000615 930f
000616 e605
000617 da2e
000618 da36
000619 910f                        do_lcd_data_i 'e' 
00061a 930f
00061b e60c
00061c da29
00061d da31
00061e 910f                        do_lcd_data_i 'l' 
00061f 930f
000620 e609
000621 da24
000622 da2c
000623 910f                        do_lcd_data_i 'i' 
000624 930f
000625 e706
000626 da1f
000627 da27
000628 910f                        do_lcd_data_i 'v' 
000629 930f
00062a e605
00062b da1a
00062c da22
00062d 910f                        do_lcd_data_i 'e' 
00062e 930f
00062f e702
000630 da15
000631 da1d
000632 910f                        do_lcd_data_i 'r' 
000633 930f
000634 e609
000635 da10
000636 da18
000637 910f                        do_lcd_data_i 'i' 
000638 930f
000639 e60e
00063a da0b
00063b da13
00063c 910f                        do_lcd_data_i 'n' 
00063d 930f
00063e e607
00063f da06
000640 da0e
000641 910f                        do_lcd_data_i 'g' 
000642 930f
000643 e200
000644 da01
000645 da09
000646 910f                        do_lcd_data_i ' ' 
000647 930f
000648 e409
000649 d9fc
00064a da04
00064b 910f                        do_lcd_data_i 'I' 
00064c 930f
00064d e704
00064e d9f7
00064f d9ff
000650 910f                        do_lcd_data_i 't'   
000651 930f
000652 e605
000653 d9f2
000654 d9fa
000655 910f                        do_lcd_data_i 'e' 
000656 930f
000657 e60d
000658 d9ed
000659 d9f5
00065a 910f                        do_lcd_data_i 'm' 
                                  
00065b ef4f                        ldi temp, 0xFF			               
00065c b948                        out PORTC, temp
00065d b94e                        out PORTE, temp                     ; turn on LEDS (need to set the top 2 LEDS as well)           
                                  
00065e e0c2
00065f e0d2
000660 2744
000661 9349
000662 8348                        clear displayCounter                ; start timer to change screen
000663 e0c0
000664 e0d2
000665 2744
000666 9349
000667 8348                        clear LEDCounter                    ; start timer to turn off LEDS
                                  
                                 EndDeliver: 
000668 914f                        pop temp 
000669 bf4f                        out SREG, temp 
00066a 914f                        pop temp 
                                 
00066b 9508                      ret
                                 
                                 
                                 .include "modules/EmptyScreen.asm"
                                 
                                 ===================================================================
                                 COMP2121                                                        
                                 Project - Vending Machine
                                 Empty Screen
                                 
                                 
                                 Lets the user know that there is more of this item in inventory
                                 ===================================================================
                                 */
                                 
                                 emptyScreen:
00066c 935f                      	push temp1
00066d b75f                      	in temp1, SREG
00066e 935f                      	push temp1
                                 
00066f 930f
000670 e001
000671 d9cd
000672 d9dc
000673 910f                      	do_lcd_command 0b00000001 			; clear display
000674 930f
000675 e006
000676 d9c8
000677 d9d7
000678 910f                      	do_lcd_command 0b00000110 			; increment, no display shift
000679 930f
00067a e00e
00067b d9c3
00067c d9d2
00067d 910f                      	do_lcd_command 0b00001110 			; Cursor on, bar, no blink
                                 
00067e 930f
00067f e40f
000680 d9c5
000681 d9cd
000682 910f                        	do_lcd_data_i 'O' 
000683 930f
000684 e705
000685 d9c0
000686 d9c8
000687 910f                        	do_lcd_data_i 'u' 
000688 930f
000689 e704
00068a d9bb
00068b d9c3
00068c 910f                      	do_lcd_data_i 't' 
00068d 930f
00068e e200
00068f d9b6
000690 d9be
000691 910f                      	do_lcd_data_i ' ' 
000692 930f
000693 e200
000694 d9b1
000695 d9b9
000696 910f                      	do_lcd_data_i ' ' 
000697 930f
000698 e40f
000699 d9ac
00069a d9b4
00069b 910f                      	do_lcd_data_i 'O' 
00069c 930f
00069d e606
00069e d9a7
00069f d9af
0006a0 910f                      	do_lcd_data_i 'f' 
0006a1 930f
0006a2 e200
0006a3 d9a2
0006a4 d9aa
0006a5 910f                      	do_lcd_data_i ' ' 
0006a6 930f
0006a7 e503
0006a8 d99d
0006a9 d9a5
0006aa 910f                      	do_lcd_data_i 'S' 
0006ab 930f
0006ac e704
0006ad d998
0006ae d9a0
0006af 910f                      	do_lcd_data_i 't' 
0006b0 930f
0006b1 e60f
0006b2 d993
0006b3 d99b
0006b4 910f                      	do_lcd_data_i 'o' 
0006b5 930f
0006b6 e603
0006b7 d98e
0006b8 d996
0006b9 910f                      	do_lcd_data_i 'c' 
0006ba 930f
0006bb e60b
0006bc d989
0006bd d991
0006be 910f                      	do_lcd_data_i 'k'   
0006bf 930f
0006c0 e200
0006c1 d984
0006c2 d98c
0006c3 910f                      	do_lcd_data_i ' ' 
                                 
0006c4 930f
0006c5 ec00
0006c6 d978
0006c7 d987
0006c8 910f                        	do_lcd_command 0b11000000  			; break to the next line   
0006c9 2d07                        	mov r16, keyID						; store the ID of requested item
0006ca d9a4                        	rcall 	print_digits 				; function to print r16 
                                 
0006cb ef5f                        	ldi temp1, 0xFF
0006cc b958                        	out PORTC, temp1					; turn on all LEDs in PORTC
0006cd e25f                        	ldi temp1, turnLEDOn				
0006ce b95e                        	out PORTE, temp1					; set bits to turn on other LEDs
                                 
0006cf e0c2
0006d0 e0d2
0006d1 2744
0006d2 9349
0006d3 8348                        	clear displayCounter				; start timer to change display
0006d4 e0c0
0006d5 e0d2
0006d6 2744
0006d7 9349
0006d8 8348                        	clear LEDCounter 					; start timer to turn off LEDs
                                 
0006d9 915f                        	pop temp1
0006da bf5f                        	out SREG, temp1
0006db 915f                        	pop temp1
                                 .include "modules/SelectScreen.asm"
0006dc 9508                      
                                 =====================================================================
                                 COMP2121
                                 Project - Vending Machine
                                 Select Screeen
                                 
                                 
                                 Displays the select screen to the LCD while also keypad input. 
                                 Depending on inventory, calls the coin collect screen or empty screen 
                                 =====================================================================
                                 */
                                 
                                 selectScreen:
0006dd 934f                      	push temp                               ; prologue starts 
0006de b74f                      	in temp, SREG
0006df 934f                      	push temp
0006e0 935f                        push temp1
                                 
0006e1 930f
0006e2 e001
0006e3 d95b
0006e4 d96a
0006e5 910f                        do_lcd_command 0b00000001 		          ; clear display
0006e6 930f
0006e7 e006
0006e8 d956
0006e9 d965
0006ea 910f                        do_lcd_command 0b00000110 		          ; increment, no display shift
0006eb 930f
0006ec e00e
0006ed d951
0006ee d960
0006ef 910f                        do_lcd_command 0b00001110 		          ; Cursor on, bar, no blink
                                 
0006f0 930f
0006f1 e503
0006f2 d953
0006f3 d95b
0006f4 910f                        do_lcd_data_i 'S' 
0006f5 930f
0006f6 e605
0006f7 d94e
0006f8 d956
0006f9 910f                        do_lcd_data_i 'e' 
0006fa 930f
0006fb e60c
0006fc d949
0006fd d951
0006fe 910f                        do_lcd_data_i 'l' 
0006ff 930f
000700 e605
000701 d944
000702 d94c
000703 910f                        do_lcd_data_i 'e' 
000704 930f
000705 e603
000706 d93f
000707 d947
000708 910f                        do_lcd_data_i 'c' 
000709 930f
00070a e704
00070b d93a
00070c d942
00070d 910f                        do_lcd_data_i 't' 
00070e 930f
00070f e200
000710 d935
000711 d93d
000712 910f                        do_lcd_data_i ' ' 
000713 930f
000714 e609
000715 d930
000716 d938
000717 910f                        do_lcd_data_i 'i' 
000718 930f
000719 e704
00071a d92b
00071b d933
00071c 910f                        do_lcd_data_i 't' 
00071d 930f
00071e e605
00071f d926
000720 d92e
000721 910f                        do_lcd_data_i 'e' 
000722 930f
000723 e60d
000724 d921
000725 d929
000726 910f                        do_lcd_data_i 'm' 
000727 930f
000728 e200
000729 d91c
00072a d924
00072b 910f                        do_lcd_data_i ' ' 
00072c 930f
00072d e200
00072e d917
00072f d91f
000730 910f                        do_lcd_data_i ' '   
000731 930f
000732 e200
000733 d912
000734 d91a
000735 910f                        do_lcd_data_i ' ' 
                                 
000736 2d56                        mov temp1, keyPress                     ; checking if key has been pressed
000737 3f5f                        cpi temp1, 0xFF
000738 f531                        brne EndSelect                          ; no key, then end function
                                 
000739 2466                        clr keyPress                            ; clear the flag to prevent further reprints to LCD             
00073a 2d07                        mov r16, keyID
                                 
00073b 300a                        cpi r16, 10                             ; checking that input is only from the numbers 
00073c f514                        brge EndSelect
                                 
00073d 93af
00073e 93bf
00073f 930f
000740 934f
000741 b74f
000742 934f
000743 e0ac
000744 e0b2
000745 3001
000746 f021
000747 5001
000748 9611
000749 940c 0745
00074b 2711
00074c 911c
00074d 914f
00074e bf4f
00074f 914f
000750 910f
000751 91bf
000752 91af                        get_element r16, Inventory, r17         ; saving the number of items of nth item (in r16) into r17
                                   
                                 
000753 3010                        cpi r17, 0
000754 f031                        breq empty                                  
                                 
000755 934f
000756 e043
000757 2e44
000758 914f                        set_reg currFlag, inCoin                ; if not zero, then item available so move onto collecting coins
                                 
000759 940c 075f                   jmp EndSelect
                                 
                                   empty:                                  ; if zero, then empty so set flag and end function
00075b 934f
00075c e044
00075d 2e44
00075e 914f                          set_reg currFlag, inEmpty
                                 
                                 
                                 	EndSelect:
00075f 915f                        pop temp1                               ; epilogue starts
000760 914f                      	pop temp
000761 bf4f                      	out SREG, temp
000762 914f                      	pop temp
000763 9508                      	ret
                                 
                                 
                                 belay:
000764 da45                        rcall debounce_sleep
000765 da44                        rcall debounce_sleep
000766 da43                        rcall debounce_sleep
000767 da42                        rcall debounce_sleep
000768 da41                        rcall debounce_sleep
000769 da40                        rcall debounce_sleep
00076a da3f                        rcall debounce_sleep
00076b da3e                        rcall debounce_sleep
00076c da3d                        rcall debounce_sleep
00076d da3c                        rcall debounce_sleep
00076e da3b                          rcall debounce_sleep
00076f da3a                        rcall debounce_sleep
000770 da39                        rcall debounce_sleep
000771 da38                        rcall debounce_sleep
000772 da37                        rcall debounce_sleep
000773 da36                        rcall debounce_sleep
000774 da35                        rcall debounce_sleep
000775 da34                        rcall debounce_sleep
000776 da33                        rcall debounce_sleep
000777 da32                        rcall debounce_sleep
000778 da31                          rcall debounce_sleep
000779 da30                        rcall debounce_sleep
00077a da2f                        rcall debounce_sleep
00077b da2e                        rcall debounce_sleep
00077c da2d                        rcall debounce_sleep
00077d da2c                        rcall debounce_sleep
00077e da2b                        rcall debounce_sleep
00077f da2a                        rcall debounce_sleep
000780 da29                        rcall debounce_sleep
000781 da28                        rcall debounce_sleep
000782 da27                          rcall debounce_sleep
000783 da26                        rcall debounce_sleep
000784 da25                        rcall debounce_sleep
000785 da24                        rcall debounce_sleep
000786 da23                        rcall debounce_sleep
000787 da22                        rcall debounce_sleep
000788 da21                        rcall debounce_sleep
000789 da20                        rcall debounce_sleep
00078a da1f                        rcall debounce_sleep
00078b da1e                        rcall debounce_sleep
00078c da1d                          rcall debounce_sleep
00078d da1c                        rcall debounce_sleep
00078e da1b                        rcall debounce_sleep
00078f da1a                        rcall debounce_sleep
000790 da19                        rcall debounce_sleep
000791 da18                        rcall debounce_sleep
000792 da17                        rcall debounce_sleep
000793 da16                        rcall debounce_sleep
000794 da15                        rcall debounce_sleep
000795 da14                        rcall debounce_sleep
000796 da13                          rcall debounce_sleep
000797 da12                        rcall debounce_sleep
000798 da11                        rcall debounce_sleep
000799 da10                        rcall debounce_sleep
00079a da0f                        rcall debounce_sleep
00079b da0e                        rcall debounce_sleep
00079c da0d                        rcall debounce_sleep
00079d da0c                        rcall debounce_sleep
00079e da0b                        rcall debounce_sleep
00079f da0a                        rcall debounce_sleep
                                 .include "modules/StartScreen.asm"
0007a0 9508                      
                                 ===================================================================
                                 COMP2121
                                 Project - Vending Machine
                                 Start Screeen
                                 
                                 
                                 The first page to be displayed just after RESET, its only job is 
                                 to print out appropriate information then return to main
                                 ===================================================================
                                 */
                                 
                                 startScreen:
0007a1 934f                      	push temp
0007a2 b74f                      	in temp, SREG
0007a3 934f                      	push temp
                                 
0007a4 930f
0007a5 e302
0007a6 d89f
0007a7 d8a7
0007a8 910f                      	do_lcd_data_i '2'
0007a9 930f
0007aa e301
0007ab d89a
0007ac d8a2
0007ad 910f                      	do_lcd_data_i '1'
0007ae 930f
0007af e302
0007b0 d895
0007b1 d89d
0007b2 910f                      	do_lcd_data_i '2'
0007b3 930f
0007b4 e301
0007b5 d890
0007b6 d898
0007b7 910f                      	do_lcd_data_i '1'
0007b8 930f
0007b9 e200
0007ba d88b
0007bb d893
0007bc 910f                      	do_lcd_data_i ' '
0007bd 930f
0007be e200
0007bf d886
0007c0 d88e
0007c1 910f                      	do_lcd_data_i ' '
0007c2 930f
0007c3 e301
0007c4 d881
0007c5 d889
0007c6 910f                      	do_lcd_data_i '1'
0007c7 930f
0007c8 e307
0007c9 d87c
0007ca d884
0007cb 910f                      	do_lcd_data_i '7'
0007cc 930f
0007cd e703
0007ce d877
0007cf d87f
0007d0 910f                      	do_lcd_data_i 's'
0007d1 930f
0007d2 e301
0007d3 d872
0007d4 d87a
0007d5 910f                      	do_lcd_data_i '1'
0007d6 930f
0007d7 e200
0007d8 d86d
0007d9 d875
0007da 910f                      	do_lcd_data_i ' '
0007db 930f
0007dc e200
0007dd d868
0007de d870
0007df 910f                      	do_lcd_data_i ' '
0007e0 930f
0007e1 e200
0007e2 d863
0007e3 d86b
0007e4 910f                      	do_lcd_data_i ' '					
0007e5 930f
0007e6 e402
0007e7 d85e
0007e8 d866
0007e9 910f                      	do_lcd_data_i 'B'	
0007ea 930f
0007eb e302
0007ec d859
0007ed d861
0007ee 910f                      	do_lcd_data_i '2'
                                 
0007ef 930f
0007f0 ec00
0007f1 d84d
0007f2 d85c
0007f3 910f                      	do_lcd_command 0b11000000			; break to the next line	
0007f4 930f
0007f5 e506
0007f6 d84f
0007f7 d857
0007f8 910f                      	do_lcd_data_i 'V'
0007f9 930f
0007fa e605
0007fb d84a
0007fc d852
0007fd 910f                      	do_lcd_data_i 'e'
0007fe 930f
0007ff e60e
000800 d845
000801 d84d
000802 910f                      	do_lcd_data_i 'n'
000803 930f
000804 e604
000805 d840
000806 d848
000807 910f                      	do_lcd_data_i 'd'
000808 930f
000809 e609
00080a d83b
00080b d843
00080c 910f                      	do_lcd_data_i 'i'
00080d 930f
00080e e60e
00080f d836
000810 d83e
000811 910f                      	do_lcd_data_i 'n'
000812 930f
000813 e607
000814 d831
000815 d839
000816 910f                      	do_lcd_data_i 'g'
000817 930f
000818 e200
000819 d82c
00081a d834
00081b 910f                      	do_lcd_data_i ' '
00081c 930f
00081d e40d
00081e d827
00081f d82f
000820 910f                      	do_lcd_data_i 'M'
000821 930f
000822 e601
000823 d822
000824 d82a
000825 910f                      	do_lcd_data_i 'a'
000826 930f
000827 e603
000828 d81d
000829 d825
00082a 910f                      	do_lcd_data_i 'c'
00082b 930f
00082c e608
00082d d818
00082e d820
00082f 910f                      	do_lcd_data_i 'h'	
000830 930f
000831 e609
000832 d813
000833 d81b
000834 910f                      	do_lcd_data_i 'i'	
000835 930f
000836 e60e
000837 d80e
000838 d816
000839 910f                      	do_lcd_data_i 'n'
00083a 930f
00083b e605
00083c d809
00083d d811
00083e 910f                      	do_lcd_data_i 'e'
00083f 930f
000840 e200
000841 d804
000842 d80c
000843 910f                      	do_lcd_data_i ' '
                                 
000844 914f                      	pop temp
000845 bf4f                      	out SREG, temp
000846 914f                      	pop temp
                                 
000847 9508                      	ret
                                 
                                 initArrays:
000848 934f                      	push temp
000849 b74f                      	in temp, SREG
00084a 934f                      	push temp
00084b 935f                      	push temp1
                                 	
00084c e051                      	ldi temp1, 1
                                 
                                 	loop:
00084d 305a                      	cpi temp1, 10
00084e f171                      	breq endLoop
00084f 2f05                      	mov r16, temp1
000850 93af
000851 93bf
000852 935f
000853 934f
000854 b74f
000855 934f
000856 e0ac
000857 e0b2
000858 3051
000859 f021
00085a 5051
00085b 9611
00085c 940c 0858
00085e 930c
00085f 914f
000860 bf4f
000861 914f
000862 915f
000863 91bf
000864 91af                      	set_element temp1 ,Inventory, r16
000865 d01c                      	rcall odd_or_even
000866 93af
000867 93bf
000868 935f
000869 934f
00086a b74f
00086b 934f
00086c e1a5
00086d e0b2
00086e 3051
00086f f021
000870 5051
000871 9611
000872 940c 086e
000874 930c
000875 914f
000876 bf4f
000877 914f
000878 915f
000879 91bf
00087a 91af                      	set_element temp1 ,Cost, r16
00087b 9553                      	inc temp1
00087c cfd0                      	rjmp loop
                                 
                                 	endLoop:
00087d 915f                      	pop temp1
00087e 914f                      	pop temp
00087f bf4f                      	out SREG, temp
000880 914f                      	pop temp
000881 9508                      	ret
                                 
                                 
                                 odd_or_even:
000882 935f                          push temp1
000883 934f                      	push temp
000884 b74f                          in temp, SREG
000885 934f                      	push temp
                                     /*
                                         9 ->       1 0 0 1
                                         1 ->     & 0 0 0 1
                                                    -------
                                                    0 0 0 1
                                 
                                         14 ->      1 1 1 0
                                         1 ->     & 0 0 0 1
                                                    -------
                                                    0 0 0 0          
                                     */
                                                 
000886 7051                          andi temp1, 1                   
000887 3050                          cpi temp1, 0
000888 f011                          breq even
000889 3051                          cpi temp1, 1
00088a f011                          breq odd
                                 
                                     even:
00088b e002                              ldi r16, 2
00088c c001                              rjmp endOop
                                     odd: 
00088d e001                              ldi r16, 1
                                 
                                 	endOop:
00088e 914f                      	pop temp
00088f bf4f                          out SREG, temp
000890 914f                      	pop temp
000891 915f                          pop temp1
000892 9508                      	ret
                                 
                                 EXT_POT:
000893 934f                      	push temp
000894 b74f                      	in temp, SREG
000895 934f                      	push temp
                                 
000896 9160 0078                 	lds ADCLow, ADCL
000898 9170 0079                     lds ADCHigh, ADCH
                                 
00089a 914f                      	pop temp
00089b bf4f                      	out SREG, temp
00089c 914f                      	pop temp
                                 
00089d 9518                      	reti
                                 
                                 EXT_INT0:
00089e 934f                      	push temp
00089f b74f                      	in temp, SREG
0008a0 934f                      	push temp
                                 
0008a1 d9cf                      	rcall empty_to_select					; to abort the empty screen if needed
0008a2 db2f                      	rcall adminAddItem						; to add an item if in Admin mode
0008a3 d906                      	rcall debounce_sleep
                                 
0008a4 914f                      	pop temp
0008a5 bf4f                      	out SREG, temp
0008a6 914f                      	pop temp
0008a7 9518                      	reti
                                 
                                 EXT_INT1:
0008a8 934f                      	push temp
0008a9 b74f                      	in temp, SREG
0008aa 934f                      	push temp
                                 
0008ab d9c5                      	rcall empty_to_select					; to abort the empty screen if needed
0008ac dae4                      	rcall adminRemoveItem					; to remove an item if in Admin mode
0008ad d8fc                      	rcall debounce_sleep
                                 
0008ae 914f                      	pop temp
0008af bf4f                      	out SREG, temp
0008b0 914f                      	pop temp
0008b1 9518                      	reti


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2560" register use summary:
x  :  18 y  :  26 z  :   0 r0 :   0 r1 :   8 r2 :   0 r3 :   0 r4 :  31 
r5 :  12 r6 :  16 r7 :  11 r8 :   5 r9 :   5 r10:  10 r11:   4 r12:   0 
r13:  11 r14:   5 r15:   0 r16: 517 r17:  84 r18:   3 r19:   3 r20: 540 
r21: 130 r22:   3 r23:   3 r24:   6 r25:   6 r26:  98 r27:  98 r28:  15 
r29:  15 r30:   0 r31:   0 
Registers used: 27 out of 35 (77.1%)

"ATmega2560" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   2 adiw  :  23 and   :   1 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  47 brge  :   3 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   5 brlt  :   0 brmi  :   0 
brne  :  43 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   5 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  55 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :  32 cpc   :   8 
cpi   :  62 cpse  :   0 dec   :   8 eicall:   0 eijmp :   0 elpm  :   0 
eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :  48 inc   :  11 jmp   :  33 ld    :  10 ldd   :   0 ldi   : 290 
lds   :  16 lpm   :   0 lsl   :   5 lsr   :   0 mov   :  62 movw  :   0 
mul   :   0 muls  :   0 mulsu :   0 neg   :   0 nop   :   0 or    :   0 
ori   :   1 out   :  85 pop   : 349 push  : 352 rcall : 391 ret   :  32 
reti  :   5 rjmp  :  33 rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 
sbi   :   5 sbic  :   0 sbis  :   0 sbiw  :   1 sbr   :   0 sbrc  :   1 
sbrs  :   0 sec   :   0 seh   :   0 sei   :   1 sen   :   0 ser   :   6 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :  34 std   :   0 sts   :  18 sub   :   4 subi  :  20 swap  :   0 
tst   :   0 wdr   :   0 
Instructions used: 39 out of 116 (33.6%)

"ATmega2560" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001164   4352      0   4352  262144   1.7%
[.dseg] 0x000200 0x00021e      0     30     30    8192   0.4%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
